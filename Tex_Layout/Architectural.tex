\documentclass[hidelinks, 12pt]{article}
\usepackage{graphicx} %For Diagrams
\usepackage{bookmark}
\usepackage{hyperref}
\begin{document}
\input{./titlepage.tex}

\section{History}
\begin{tabular}{|l|l|l|}
%General Format: ??-03-2015 & Version *.* & Action by Name
\hline
Date & Version & Description\\
\hline
04-03-2015 & Version 0.1 & Document Template created - Keagan\\
\hline
04-03-2015 & Version 0.2 & Added Name and Student Number - Keagan\\
\hline
04-03-2015 & Version 0.3 & Added Name and student Number - Matthew\\
\hline
04-03-2015 & Version 0.4 & Added Name and Student Number - Maret\\
\hline
04-03-2015 & Version 1.0 & Added to my section - Maret\\
\hline
05-03-2015 & Version 1.1 & Added Name and Student Number - Patience\\
\hline
05-03-2015 & Version 1.2 & Deleted BitBucket folder and recompiled PDF - Keagan\\
\hline
06-03-2015 & Version 2.0 & Updated file - Latham\\
\hline
06-03-2015 & Version 2.1 & Updated - Latham\\
\hline
06-03-2015 & Version 2.2 & Updated - Latham\\
\hline
07-03-2015 & Version 3.0 & Added section 3.1.1 - Human Access Channels - Matthew\\
\hline
08-03-2015 & Version 3.1 & Update Quality requirements - Maret\\
\hline
08-03-2015 & Version 3.2 & Update sections - Maret\\
\hline
09-03-2015 & Version 3.3 & Added to section 3.3.(Integration Requirements) - Patience\\
\hline
10-03-2015 & Version 3.4 & Fixed a tag that was stopping the compilation of the \\&&PDF - Keagan\\
\hline
10-03-2015 & Version 3.5 & Added my sections - Abrie\\
\hline
10-03-2015 & Version 3.6 & Added my final part - Abrie\\
\hline
10-03-2015 & Version 3.7 & Added rest of my sections - Matthew\\
\hline
10-03-2015 & Version 3.8 & Adding Architecture Tactics - Keagan\\
\hline
10-03-2015 & Version 4.0 & Cleaned up the PDF a bit and checked Quality \\&&Requirements - Keagan\\
\hline
10-03-2015 & Version 4.1 & Added names to title page - Johan\\
\hline
11-03-2015 & Version 4.2 & Removed/Merged duplicate sections - Matthew\\
\hline
11-03-2015 & Version 4.3 & Updated history section - Keagan\\
\hline



\end{tabular}

\newpage
\tableofcontents
\newpage

\section{Introduction}
%Intro to be added

\subsection{Purpose}
%Purpose to be added

\subsection{Background}
%Project Scope to be added

\section{Architecture Requirements}

% Architectural scope

\subsection{Architectural Scope}
\begin{description}
\item[$\bullet$Concurrent processing environment:]

Buzz will have to run on a multi-threaded environment, we need multiple users to be connected and exchange messages concurrently. This has to run on one or more concurrent managers.\\\\
Buzz will run on a Cluster environment:\\
Multiple computers will share a common computer server. The cluster that could possibly be used is IBM High Availability Cluster Multiprocessing. It runs on multiple computers and when one fails the other takes over.\\\\
This provides the following benefits to Buzz system:
\begin{description}
\item[$\bullet$] High performance: improve concurrent processing throughput.
\item[$\bullet$]Adaptability: the ability to integrate with platform-specific batch queue and load-balancing systems to maximize concurrent processing performance on a particular platform.
\item[$\bullet$] Fault Tolerance: when other nodes/threads fail, the system should continue running. It is easier to administer the entire system and concurrent managers.\\
\end{description}

\item[$\bullet$Temporary or permanent storage environment:]

Temporary storage environment: Concerning user data, all information will be cached into the browser. UserID, password, etc can all be stored in cookies.\\
Permanent storage environment: Database and use of flash drives, this is to store system images.\\

\item[$\bullet$Scheduling:]

After some intervals the system must be able to store its image to avoid data loss in case of power shutdown or other causes. This could be done, or stored in some non-volatile storage, could be in a hard drive. After system reboot all the data can be simply recovered whenever there occurs any problem.\\

\item[$\bullet$Integration environment:]

For a basic integration environment, client-server architecture would be deployed. System management server would provide single interface through which administrators can explore and manage metadata repositories. We can manage data with some studio (actual environment where data will be stored and integrated with other information) which provides a single point of control user and system data. With appropriate access and integration channels the studio and system management would communicate through multiple servers.\\

\item[$\bullet$Persistence infrastructure:]

When system shut-down, Buzz state must be maintain with persistence infrastructure. With the Database management systems (DBMS), we can achieve persistence and also services such as queries, auditing and access control. Persistence can also be achieve with system images: after some scheduling system image must be stored. State changes made to a system after its last image was saved are lost in the case of a system failure or shut-down. There are other persistence techniques that can be well integrated with Buzz, such as journals and dirty writes.\\

\item[$\bullet$Providing a reporting infrastructure:]

All global reports must be stored in a file system, created with JAVA programming language. This would be done with the created user interface (UI). Alternatively, depending on the integration channels and their protocols all reports that need to be generated can be store in the integrated database.\\

XML - this can be used to store temporary reports that need to be delivered in a certain time interval. This reduces access time and easy to maintain.\\

\end{description}



%Short description of following contents
\subsection{Access Channel Requirements}

\subsubsection{Human access channels}
Human users should be able to access the system from all major devices and software. These include Windows, Linux, Mac OS, Windows Mobile, Android, and iOS devices. Human users will be able to access the system via thick desktop applications, as well as thin web clients. 
\\\\However it is expected most access will be via thin web clients.
The system may be accessed via all major browsers, namely Internet Explorer, Mozilla Firefox, Google Chrome, Opera and Safari. The system will comply with the basic W3C requirements to accomplish this goal.
\\\\The REST architecture is the primary candidate to implement communication between users and the system, with a backup choice of the SOAP architecture.

\subsubsection{System access channels}
In the scope of this project, no systems will require access to Buzz. However, when Buzz is integrated with Hamster, it should provide the necessary API (over HTTP) to interface with the Hamster Marking System.

\subsubsection{Integration channels}
The system must be able to integrate with the University's CS-LDAP (Light-Weight Directory Access Protocol) server. As well as the server which will store the uploaded media, such as images, videos, PDFs and the like. The system will therefor need to handle the LDAP, HTTP, SMTP (or other email protocols) and SMS protocols. The Buzz system will be integrated into the CS website such that when a user logs into the CS website, they will also be logged into Buzz System automatically.


\subsection{Quality Requirements}
%Quality Requirements to be added - Keagan & Maret
\begin{description}
  \item[Scalability:] 
        The software system must be able to handle the registration and data of all the users registered on the LDAP server. 
       If several users attempt to do the same action simultaneously, like commenting in a thread, the actions should appear to happen one at a time. 
      The system must not have a maximum or minimum amount of users that may use the system at a time.
  \item[Performance requirement:]
      The system must have a fast response time. The system must be able to handle all the users and not slow down.
  \item[Maintainability:] 
      The system must be easy to update and maintain.
  \item[Reliability and Availability:]
      The system must be usable on any modern web browser and operating system.
  \item[Security:]
      All the user's information must be secure and only be visible or editable for users with the required permissions. All the data must be inaccessible for non-users.
  \item[Monitorability and Auditability:]
      A log of all user activity must be available for the administration. The information that must be available for auditability are: users and their details, posts, deleted messages, and all actions performed.
  \item[Testability:]
      An interface must be available to certain staff of the system to enable extreme case testing of the system's functionality, and the actual user interface must be thoroughly tested to decrease the likelihood of a user finding a fault. In order for these two types of testing to be conducted effectively, the system must be made as controllable and observable as possible.
  \item[Usability:]
      The Buzz system must be easy to use. It can make use of UI metaphors like a having a "post-it" symbol for the post operation or an envelope for the messages link.
      The most common used operations must perform very quickly. The system must be easy to learn so new users can adapt to it without help. 
      The validation and error messages must be clear and understandable.
  \item[Integrability:]
      The system must be integrated with the LDAP server. 
      All the data on the server like names, photos registered modules, etc. are used in the buzz system. 
\item[Security:]
The integration interface must be secure, i.e. any information obtained from the LDAP server about any user should be used in the Buzz system only .
\end{description}
\subsection{Architecture Constraints}
%Architecture Constraints to be added - Johan & Latham

The architecture constraints were indicated in the briefing document and the following is a list of technologies we are going to use in the project:

\begin{description}
  \item[$\bullet$] Linux (Operating System):
  Linux is more stable than windows on servers. It is free and does not need added costs. Thus it makes a good OS to use. There is a lot of free software that runs on it, but there is also software that only runs on Windows. 
  
  \item[$\bullet$] Git (Version Control System):
  Git is good for group projects and information share. It can show the progress and the group’s efforts in completing the project. It is not always easy to use, sometimes it can break and work need to be restored from a previous version.
  
  \item[$\bullet$] JavaEE (Java Platform Enterprise Edition):
  For server programming Java EE would suffice, it is reliable and easier to use. Even though it is a bit slower and is resource intensive. It makes a good framework that incorporates JPA,  JPQL and JSF.
  
  \item[$\bullet$]JPA (Java Persistence AP):
  JPA uses JPQL so it would be better to use this, it operates against entity object rather than with database tables. Most of the developers have not yet practised with this technology which leads to inexperience with this. 
  
  \item[$\bullet$] JPQL (Java Persistence query language):
  Is used to make queries against entities stored in a relational database and additionally retrieve objects from the database on the server. It would be used to retrieve user data and etc. Most of the developers have not yet practised with this technology which leads to inexperience with this. 
  
  \item[$\bullet$] JSF ( Java Server Faces):
  Is a Java specification for building component-based UI for web applications and exposing them as server side Polyfills. This works with AJAX. Most of the developers have not yet practised with this technology which leads to inexperience with this. 
  
  \item[$\bullet$] HTML (Hypertext Mark-up Language):
  This is going to be code that has to be generated for the website where the user can navigate through, the browser takes this code, interprets it and give a UI for the user. 
  
  \item[$\bullet$] AJAX (Asynchronous JavaScript and XML):
  It is easier to use, rather than having to make our own function for everything. This is client side processing so that we don’t hassle the servers with little tests.
  
  \item[$\bullet$] CSS (Cascading Style-sheet):
  This is the coding platform we are going to use to make the website more attractive and to fill the emptiness of the website.
\end{description}

\section{Architectural patterns or styles}
\subsection{Layering Architectural Pattern}
The layering pattern allows for separation of concerns between the different layers. Due to each layer having its own responsibilities the system becomes very flexible and layers can be re-used due to the de-coupling. For example the front-end of the system can be separate from the infrastructure and how services are handled.\\
Possible layers to implement: 
\begin{description}
\item[$\bullet$]Human/Client Access Layer
\item[$\bullet$]System Access Layer
\item[$\bullet$]Services Layer
\item[$\bullet$]Infrastructure Layer
\end{description}
The layers can either communicate with components within the same layer, or with components in the next layer down. This provides the connection between the layers, and manages the communication
in a structured fashion. The channel in which this communication can be achieved is via message passing between the layers.

\subsection{MVC Architectural Pattern}
Model-view-controller (MVC) is a software architectural pattern. When the MVC pattern is applied, an application is divided into three logical, interconnected parts. These parts are meant to isolate the presentation, business logic and data access aspects of the application. Adhering to this pattern results in implementations that are highly scalable and robust. Individual, M-V-C, components of the system can be physically disjoined and can account for less maintenance and housekeeping at each of their servers. This will aid in the separation of concerns: Back- and front-end modules can be neatly separated and this translates into a better, more parallel, development environment.

\subsection{REST Architectural Pattern}
The Representational State Transfer (REST) architectural pattern is an already highly used and tested pattern for scalable web services.
The REST pattern functions by a coordinated set of constraints that govern how the Client and Server interact, and this specified set of constraints creates properties such as performance, scalability and modifiability. 
It is a stateless pattern, whereby there is no context stored on the server about the client.
Since the user base of the Buzz system can be expected to grow to quite a large number, a RESTful approach would constitute less network hogging. This would also lead to a much simpler design since the server will only keep little session information about the client.

\section{Architectural tactics or strategies}
\begin{description}
  \item[$\bullet$ Functional Decomposition]
  By decoupling functionality, the system has functions that are smaller and a lot more specific, resulting in a great deal more scalability as you have more flexibility to scale them independently of one another at a lower resource cost. Additionally, this allows for greater availability as functions can now run to completion even if another function encounters errors in execution, assuming that error does not crash the system.
  \item[$\bullet$ Virtualisation at All Levels]
  By creating multiple terminals out of the hardware, the system can adequately be shared between multiple users and this will no doubt extend the scalability of the system as more users will be able to efficiently access and use the system, without the entire system crashing if one user causes their part of the system to go down/stop execution.
  \item[$\bullet$ Use Concurrency]
  When dealing with the use of resources, the access time to acquire them is a factor but blocked time is a more severe problem when multiple users are on a system at once. By allowing requests to be processed in parallel, blocked time is reduced which improves the system's performance and thus speeds up the user's work.
  \item[$\bullet$ Employ Active Redundancy]
  Our system promises to be available to students whenever they need it, so availability is a big quality that we need to guarantee.
  Redundant components, which respond to events in parallel, are all in the same state. When a request is made, only the fastest response is needed, even though the rest of the components produce the same response nevertheless. This is done so that should one of these components fail, virtually no downtime is experienced by the system because it will still receive a response from one of the components which are still up, so availability is not a problem. 
\end{description}

\section{Use of reference architectures and frameworks}
%Use of reference architectures and frameworks to be added
There exist many reference architectures and/or frameworks which we can incorporate and use in our project. The API's already exist and can mainly be used as simple plugins.

Java-EE, which is a Layered Reference Architecture would be best suited for the current system, because it comprehensively includes a majority of our Quality Requirements that we want to achieve (like Scalability, Security etc).
\subsection{Check for Plagiarism}
Plagiarism-Checker (\url{https://github.com/architshukla/Plagiarism-Checker}) searches online by using Google Search API's to address queries. The URL you get from the query are checked for similarities with the information you are checking. Results are stored in an output text file. Checking user posts for plagiarism is of cardinal value, since it helps grow an air of responsible sharing in the users.
\subsection{Highlighting Syntax}
SyntaxHighlighter 3.0.83 (\url{http://alexgorbatchev.com/SyntaxHighlighter/}) is a self-contained syntax highlighter specifically for code. It is used in, among others, Apache, Mozilla, Wordpress and Freshbooks. It is developed in Javascript and works no matter what kind of server you are running. Using this plugin can ease the process of sharing code in the discussion area and help see what is part of syntax and what is not.
\subsection{Profanity Filter}
A profanity filter is a must to maintain order and control in an online discussion area. Without it, users can post what they like, when they like without any sort of service or function prohibiting their possibly damaging posts. PurgoMalum (\url{http://www.purgomalum.com/}) is a free web service for filtering content. It can filter out curse words, other obscenities and general unwanted words as well. WebPurify (\url{http://www.webpurify.com/}) can also be used - it is much more versatile than PurgoMalum, as it can moderate images and videos as well, at a fee of course.
\subsection{Font Sizes according to screen size}
The trouble with font on webpages is usually flexibility and scalability when it comes to displaying your webpage headlines on different screen sizes. Herein lies the absolute marvel that is FitText (\url{http://fittextjs.com/}). This plugin is an open-source project available on github, that makes headline font sizes scalable to different screen types and sizes.

\section{Technologies}
%Technologies to be added

\section{Conclusion}
%Conclusion to be added

\section{References}
%References to be added

\end{document}


