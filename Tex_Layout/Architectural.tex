\documentclass[12pt]{article}\usepackage{graphicx} %For Diagrams\usepackage{bookmark}\usepackage{hyperref}\begin{document}\input{./titlepage.tex}\section{History}\begin{tabular}{|l|l|l|}%General Format: ??-03-2015 & Version *.* & Action by Name\hlineDate & Version & Description\\\hline04-03-2015 & Version 0.1 & Document Template created - Keagan\\\hline07-03-2015 & Version 0.2 & Added section 3.1.1 - Matthew\\\hline\end{tabular}\newpage\tableofcontents\newpage\listoffigures\newpage\section{Introduction}%Intro to be added\subsection{Purpose}%Purpose to be added\subsection{Background}%Project Scope to be added\section{Architecture Requirements}%Short description of following contents\subsection{Access Channel Requirements}\subsubsection{Human access channels}Human users should be able to access the system from all major devices and software. These include Windows, Linux, Mac OS, Windows Mobile, Android, and iOS devices. Human users will be able to access the system via thick desktop applications, as well as thin web clients. \\\\However it is expected most access will be via thin web clients.The system may be accessed via all major browsers, namely Internet Explorer, Mozilla Firefox, Google Chrome, Opera and Safari. The system will comply with the basic W3C requirements to accomplish this goal.\\\\The REST architecture is the primary candidate to implement communication between users and the system, with a backup choice of the SOAP architecture.\subsubsection{System access channels}In the scope of this project, no systems will require access to Buzz. However, when Buzz is integrated with Hamster, it should provide the necessary API (over HTTP) to interface with the Hamster Marking System.\subsubsection{Integration channels}The system must be able to integrate with the University's CS-LDAP (Light-Weight Directory Access Protocol) server. As well as the server which will store the uploaded media, such as images, videos, PDFs and the like. The system will therefor need to handle the LDAP, HTTP, SMTP (or other email protocols) and SMS protocols.\subsection{Quality Requirements}%Quality Requirements to be added - Keagan & Maret\begin{description}  \item[Scalability:]         The software system must be able to handle the registration and data of all the users registered on the LDAP server.        If several users attempt to do the same action simultaneously, like commenting in a thread, the actions must appear to happen one at a time.       The system must not have a maximum or minimum amount of users that may use the system at a time  \item[Performance requirement:]      The system must have a fast response time. The system must be able to handle all the users and not become slower.  \item[Maintainability:]       The system must be easy to update and maintain.  \item[Reliability and Availability:]      The system must be usable on any (modern) web browser and operating system.  \item[Security:]      All the users information must be secure and only be visible or editable for users with the required permissions. All the data must be unaccesable for non-users.  \item[Monitorability and Auditability:]      A log of all user activity must be available for the adminitration. The information that must be available for auditability are: users and their details, posts, deleted messages, and all activities.  \item[Testability:]  \item[Usability:]      The Buzz sytem must be easy to use. It can make use of UI metaphors like a having a "post-it" symbol for the post operation or an envelope for the messages link.      The most common used operations must perform very quickly. The system must be easy to learn so new users can adapt to it without help.       The validation and error messages must be clear and understandable.  \item[Integrability:]      The system mut be integrated with the LDAP server.       All the data on the server like names, photos registered modules, etc are used in the buzz system. \end{description}\subsection{Integration Requirements}%Integration Requirements to be added - Patience & Hlavutelo%The Buzz system will be integrated into the CS website such that when a user logs into the CS website, they will also be logged into Buzz System automatically.The system must be integrated with the LDAP server to obtain user information.\subsection{Quality Requirements}\begin{description}\item[$\bullet$]SecurityThe integration interface must be secure, i.e. any information obtained from the LDAP server about any user should be used in the Buzz system only .\end{description}\subsection{Architecture Constraints}%Architecture Constraints to be added - Johan & LathamThe architecture constraints were indicated in the briefing document and the following is a list of technologies we are going to use in the project:\begin{description}  \item[$\bullet$] Linux (Operating System):  Linux is more stable than windows on servers. It is free and does not need added costs. Thus it makes a good OS to use. There is a lot of free software that runs on it, but there is also software that only runs on Windows.     \item[$\bullet$] Git (Version Control System):  Git is good for group projects and information share. It can show the progress and the group’s efforts in completing the project. It is not always easy to use, sometimes it can break and work need to be restored from a previous version.    \item[$\bullet$] JavaEE (Java Platform Enterprise Edition):  For server programming Java EE would suffice, it is reliable and easier to use. Even though it is a bit slower and is resource intensive. It makes a good framework that incorporates JPA,  JPQL and JSF.    \item[$\bullet$]JPA (Java Persistence AP):  JPA uses JPQL so it would be better to use this, it operates against entity object rather than with database tables. Most of the developers have not yet practised with this technology which leads to inexperience with this.     \item[$\bullet$] JPQL (Java Persistence query language):  Is used to make queries against entities stored in a relational database and additionally retrieve objects from the database on the server. It would be used to retrieve user data and etc. Most of the developers have not yet practised with this technology which leads to inexperience with this.     \item[$\bullet$] JSF ( Java Server Faces):  Is a Java specification for building component-based UI for web applications and exposing them as server side Polyfills. This works with AJAX. Most of the developers have not yet practised with this technology which leads to inexperience with this.     \item[$\bullet$] HTML (Hypertext Mark-up Language):  This is going to be code that has to be generated for the website where the user can navigate through, the browser takes this code, interprets it and give a UI for the user.     \item[$\bullet$] AJAX (Asynchronous JavaScript and XML):  It is easier to use, rather than having to make our own function for everything. This is client side processing so that we don’t hassle the servers with little tests.    \item[$\bullet$] CSS (Cascading Style-sheet):  This is the coding platform we are going to use to make the website more attractive and to fill the emptiness of the website.\end{description}\section{Architectural patterns or styles}\subsection{Layering Architectural Pattern}The layering pattern allows for separation of concerns between the different layers. Due to each layer having its own responsibilities the system becomes very flexible and layers can be re-used due to the de-coupling. For example the front-end of the system can be separate from the infrastructure and how services are handled.\\Possible layers to implement: \begin{description}\item[$\bullet$]Human/Client Access Layer\item[$\bullet$]System Access Layer\item[$\bullet$]Services Layer\item[$\bullet$]Infrastructure Layer\end{description}The layers can either communicate with components within the same layer, or with components in the next layer down. This provides the connection between the layers, and manages the communicationin a structured fashion. The channel in which this communication can be achieved is via message passing between the layers.\subsection{MVC Architectural Pattern}Model-view-controller (MVC) is a software architectural pattern. When the MVC pattern is applied, an application is divided into three logical, interconnected parts. These parts are meant to isolate the presentation, business logic and data access aspects of the application. Adhering to this pattern results in implementations that are highly scalable and robust. Individual, M-V-C, components of the system can be physically disjoined and can account for less maintenance and housekeeping at each of their servers. This will aid in the separation of concerns: Back- and front-end modules can be neatly separated and this translates into a better, more parallel, development environment.\subsection{REST Architectural Pattern}The Representational State Transfer (REST) architectural pattern is an already highly used and tested pattern for scalable web services.The REST pattern functions by a coordinated set of constraints that govern how the Client and Server interact, and this specified set of constraints creates properties such as performance, scalability and modifiability. It is a stateless pattern, whereby there is no context stored on the server about the client.Since the user base of the Buzz system can be expected to grow to quite a large number, a RESTful approach would constitute less network hogging. This would also lead to a much simpler design since the server will only keep little session information about the client.\section{Architectural tactics or strategies}%Architectural tactics or strategies to be added\section{Use of reference architectures and frameworks}%Use of reference architectures and frameworks to be added\section{Access and integration channels}%Access and integration channels to be added\section{Technologies}%Technologies to be added\section{Conclusion}%Conclusion to be added\section{References}%References to be added\end{document}